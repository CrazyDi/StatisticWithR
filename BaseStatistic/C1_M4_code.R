# Описательная статистика ------------------------
# М.А. Варфоломеева, PhD
# Биологический факультет, СПбГУ


# Для чего используются данные  -----------------------



# Медиана и квантили  -----------------------

# Медиана делит отсортированный ряд наблюдений на две равные части

# Стоимость обеда в кафе

# Предположим, что вы в командировке и 6 дней
# обедаете в кафе. Медианная стоимость обеда
# покажет ваши траты. В половине случаев вы
# тратите меньше медианной стоимости обеда, а в
# половине --- больше.
lunch <- c('Пн' = 310, 'Вт' = 298, 'Ср' = 363, 'Чт' = 336, 'Пт' = 285, 'Сб' = 320)

# В ряду четное число наблюдений, поэтому медианная стоимость обеда --- среднее между двумя центральными значениями в отсортированном ряду.
sort(lunch)

# Медиану можно вычислить при помощи функции `median()`
median(lunch)

# Если в ряду нечетное число наблюдений, то медиана совпадает с центральным значением отсортированного ряда

# Предположим, что вам пришлось в обедать и в воскресенье
lunch_week <- c(lunch, 'Вс' = 430)
sort(lunch_week)
median(lunch_week)

# Квантили --- это значения, которые делят ряд наблюдений на равные части

# Квартили вместе с минимумом и максимумом
# (5-number summary)
quantile(lunch)

# Какие значения отсекают 10% или 99% значений выборки?
quantile(lunch, probs = c(0.10, 0.99))



# Боксплоты  -----------------------

# Боксплот можно построить при помощи `geom_boxplot()`

library(ggplot2)
theme_set(theme_bw())

lunch_data <- data.frame(price = lunch)

ggplot(data = lunch_data) +
  geom_boxplot(aes(x = 'Медиана \nи квантили', y = price)) +
  labs(x = 'Обед', y = 'Стоимость обеда')


# Среднее и стандартное отклонение -----------------------

# Среднее значение (Mean) --- это еще один способ описать центральное значение ряда наблюдений

# Рассчитаем вручную и проверим:
sum(lunch) / length(lunch)
mean(lunch)

# Как оценить разброс значений вокруг среднего?

# Девиата (отклонение) --- это разность между значением измерения и средним
deviate <- lunch - mean(lunch)
round(deviate, 1)

# Девиаты не получится использовать, как меру разброса, т.к. их сумма равна нулю
round(sum(deviate))

# Сумма квадратов отклонений (SS, Sum of Squares) уже не будет равна нулю
sum(deviate^2)

# Дисперсия --- средний квадрат отклонений (Variance, MS, Mean Square)
sum(deviate^2) / (length(lunch) - 1)
var(lunch)

# Стандартное (его еще называют "среднеквадратичное") отклонение (SD, Standard Deviation)
sqrt(sum(deviate^2) / (length(lunch) - 1))
sd(lunch)


# Среднее и стандартное отклонение при помощи `stat_summary()`
ggplot(data = lunch_data) +
  stat_summary(geom = 'pointrange', fun.data = mean_sdl, fun.args = list(mult = 1),
               aes(x = 'Среднее \nи стандартное отклонение', y = price)) +
  labs(x = 'Обед', y = 'Стоимость обеда')


# Как соотносятся способы оценки центра и размаха в выборке?
ggplot(data = lunch_data) +
  geom_boxplot(aes(x = 'Медиана \nи квантили', y = price)) +
  stat_summary(geom = 'pointrange', fun.data = mean_sdl, fun.args = list(mult = 1),
               aes(x = 'Среднее \nи стандартное отклонение', y = price)) +
  labs(x = 'Обед', y = 'Стоимость обеда')
# Медиана и среднее дают сходные результаты, если выборка не содержит сильно отличающихся наблюдений.



# Устойчивость среднего и медианы к выбросам  -----------------------

# Наблюдения, далеко отстоящие от остальных, называются "выбросы" (outliers)
# Важно проверять данные на наличие выбросов.

# Оксфорд против Кембриджа
# Как распределен вес членов лодочной команды? Все ли они весят одинаково?
# Данные в файле boatmen.xlsx
# - team --- команда (Кембридж или Оксфорд)
# - weight --- вес, кг
# Источник данных: Hand, D. J. et al., 1994, p. 337
# Данные: The Independent, March 31, 1992}


# Знакомимся с данными
library(readxl)
boatmen <- read_excel('data/boatmen.xlsx', sheet = 'data')

str(boatmen)            # Правильно ли открылись данные?

colSums(is.na(boatmen)) # Нет ли пропущенных значений?

table(boatmen$team)     # Сколько человек в каждой команде?


# Строим боксплот
ggplot(data = boatmen, aes(x = team, y = weight)) +
  geom_boxplot()

# Добавим цвет, подпишем названия команд и оси
ggplot(data = boatmen, aes(x = team, y = weight)) +
  geom_boxplot(fill = 'powderblue', width = 0.2) +
  scale_x_discrete(labels = c('Кембридж', 'Оксфорд')) +
  labs(x = 'Команда', y = 'Вес, кг')

# Кто этот легкий человек в каждой команде?

# Сравним устойчивость медианы и среднего к присутствию сильно отклоняющихся значений

# Первый способ, можно вручную отфильтровать "выброс"

# Экипаж Оксфордской команды целиком
f_oxford <- boatmen$team == 'Oxford'
ox <- boatmen$weight[f_oxford]
ox
median(ox)
mean(ox)

# без рулевого
id_cox <- which.min(ox)
ox[-id_cox]
median(ox[-id_cox])
mean(ox[-id_cox])


# То же самое удобно посчитать для всех сразу при
# помощи функций из пакета `dplyr`

library(dplyr)
boatmen %>%           # весь экипаж
  group_by(team) %>%
  summarize(.median = median(weight),
            .mean = mean(weight))

boatmen %>%
  filter(weight > 70) %>%   # только гребцы
  group_by(team) %>%
  summarize(.median = median(weight),
            .mean = mean(weight))


# Можно на графиках сравнить, как меняются медиана
# и среднее при удалении "выбросов"

# Два графика с медианой и квартилями: вместе с рулевым и без него
# `%+%` --- оператор, который заменяет датасет в исходном графике

gg_median <- ggplot(data = boatmen, aes(x = team, y = weight)) +
  geom_boxplot(fill = 'powderblue', width = 0.2) +
  scale_x_discrete(labels = c('Кембридж', 'Оксфорд')) +
  labs(x = 'Команда', y = 'Вес, кг') +
  coord_cartesian(ylim = c(50, 100)) +
  ggtitle('Вместе с рулевым')

gg_median_without_cox <- gg_median %+% boatmen[boatmen$weight > 70, ] +
  ggtitle('Без рулевого')

# Аналогично два графика со средним и стандартным отклонением:
# вместе с рулевым и без него

gg_mean<- ggplot(data = boatmen, aes(x = team, y = weight)) +
  stat_summary(geom = 'pointrange', fun.data = mean_sdl, fun.args = list(mult = 1)) +
  scale_x_discrete(labels = c('Кембридж', 'Оксфорд')) +
  labs(x = 'Команда', y = 'Вес, кг') +
  coord_cartesian(ylim = c(50, 100)) +
  ggtitle('Вместе с рулевым')

gg_mean_without_cox <- gg_mean %+% boatmen[boatmen$weight > 70, ] +
  ggtitle('Без рулевого')

# Медиана и квартили более устойчивы к "выбросам",
# чем среднее и стандартное отклонение
library(cowplot)
plot_grid(gg_median,
          gg_median_without_cox,
          gg_mean,
          gg_mean_without_cox,
          ncol = 2)


# Среднее и медиана для симметричных и несимметричных распределений ------------

# Медиана и квартили для несимметричных
# распределений информативнее, чем связка
# среднее-стандартное отклонение

# 5000+ фильмов
# В датасете `movie_metadata.csv` содержится
# информация о 28 признаках 5043 фильмов,
# собранная при помощи веб-скреппинга с сайта
# IMDB.com.
# - Каковы типичные кассовые сборы для фильмов?
# - Какую оценку обычно получают фильмы на IMDB?
# - Что лучше для представления данных --- среднее и
# стандартное отклонение или медиана и квартили?

# Данные: \href{https://chuansun76.com/2016/09/23/how-to-tell-the-greatness-of-a-movie-before-it-is-released-in-cinema/}{Chuan Sun}

# Знакомимся с данными

mov <- read.csv('data/movie_metadata.csv', header = TRUE, na.strings = '')
colnames(mov)

# Нам понадобятся `gross` --- суммарная выручка и
# `imdb_score` --- рейтинг на IMDB.com

# О форме распределения мы можем судить уже по
# значениям квантилей и среднего
summary(mov$gross)
summary(mov$imdb_score)

# Значительно удобнее было бы изобразить все это на графике
# Например, можно сверху изобразить гистограмму, а
# внизу --- боксплот, положенный на бок.

# Построим графики для распределения выручки

# Гистограмма
gg1 <- ggplot(data = mov, aes(x = gross)) +
  geom_histogram(colour = 'black', fill = 'powderblue') +
  coord_cartesian(xlim = range(mov$gross, na.rm = TRUE))

# Боксплот и график среднего и стандартного отклонения
gg2 <- ggplot(data = mov, aes(x = '', y = gross)) +
  geom_boxplot(fill = 'powderblue') +
  stat_summary(geom = 'pointrange', fun.data = mean_sdl, fun.args = list(mult = 1),
               shape = 108, size = 2, colour = 'orangered') +
  coord_flip(ylim = range(mov$gross, na.rm = TRUE))

# Распределение кассовых сборов для `r nrow(mov) -
# sum(is.na(mov$gross))` фильмов
summary(mov$gross)
plot_grid(gg1, gg2, ncol = 1, align = 'v', rel_heights = c(0.6, 0.4))

# Графики для распределения рейтингов фильмов на
# IMDB можно построить аналогично

# Гистограмма
gg3 <- ggplot(data = mov, aes(x = imdb_score)) +
  geom_histogram(colour = 'black', fill = 'powderblue') +
  coord_cartesian(xlim = range(mov$imdb_score, na.rm = TRUE))

# Боксплот и график среднего и стандартного отклонения
gg4 <- ggplot(data = mov, aes(x = '', y = imdb_score)) +
  geom_boxplot(fill = 'powderblue') +
  stat_summary(geom = 'pointrange', fun.data = mean_sdl, fun.args = list(mult = 1),
               shape = 108, size = 2, colour = 'orangered') +
  coord_flip(ylim = range(mov$imdb_score, na.rm = TRUE))

# Распределение рейтингов для `r nrow(mov) -
# sum(is.na(mov$imdb_score))` фильмов
summary(mov$imdb_score)
plot_grid(gg3, gg4, ncol = 1, align = 'v', rel_heights = c(0.6, 0.4))


# Одно из симметричных распределений играет особенную роль в статистике
# О нормальном распределении мы поговорим подробнее

# Нормальное распределение  -----------------------

# Стандартное нормальное распределение. Стандартизация  -----------------------

# Нормальное распределение со средним значением $\mu = 0$ и стандартным отклонением $\sigma = 1$ называется __стандартное нормальное распределение__.

# Стандартизация (Z-преобразование)

# Стандартизацию можно применять не только к нормально-распределенным величинам

# Стандартизация позволяет уравнять шкалы, в которых измерены переменные



# Проверка на нормальность при помощи квантильного графика --------------

# Квантильный график (Quantile-Quantile plot, QQ plot)

set.seed(2385792)
my_vector <- rnorm(n = 150, mean = 10, sd = 3)
library(car)
qqPlot(my_vector) # квантильный график





# Кого возьмут в пилоты? Оценка вероятностей при помощи распределений  -----------------------

# Кого возьмут в пилоты?
# В пилоты берут только людей с ростом от 160 до
# 190 см (по приказу Минтранса). Какова доля
# мужчин и женщин, подходящих по росту в пилоты?
# Параметры распределений роста для России можно
# найти в медицинских таблицах.

# Какова доля мужчин с ростом меньше 160 см?

# Средний рост юношей в 18 лет --- 174.7 см со
# стандартным отклонением 6.65 см

# Можно стандартизовать значение и вычислить
# вероятность при помощи стандартного нормального
# распределения.
Z_male_160 <- (160 - 174.7) / 6.65
pnorm(q = Z_male_160)

# R позволяет вычислять вероятности без
# предварительной стандартизации, если указать
# параметры нормального распределения.
pnorm(q = 160, mean = 174.7, sd = 6.65)

# Какова доля мужчин с ростом __меньше 190 см__?
pnorm(q = 190, mean = 174.7, sd = 6.65)

# Какова доля мужчин, подходящих по росту в пилоты?
pnorm(q = 190, mean = 174.7, sd = 6.65) -
  pnorm(q = 160, mean = 174.7, sd = 6.65)


# Какова доля девушек, подходящих по росту в пилоты?

# Средний рост девушек в 16 лет --- 162.2 см, со
# стандартным отклонением 6.0 см.

pnorm(q = 190, mean = 162.2, sd = 6.0) -
  pnorm(q = 160, mean = 162.2, sd = 6.0)



# Выборочная оценка среднего значения  -----------------------

# Доверительный интервал  -----------------------


#  Доверительный интервал (при помощи нормального распределения)
# --- это интервал в который попадает 95% выборочных средних.

# Чтобы его найти, нам нужно определить квантили
# стандартного нормального распределения, которые
# соответствуют его границам
qnorm(p = c(0.025, 0.975))



# Доверительный интервал при помощи $t$-распределения
# Расчет и изображение доверительного интервала в R -------------------

# Вернемся к датасету 5000+ фильмов
# Каков средний рейтинг (и доверительный интервал
# к нему) для черно-белых и цветных фильмов?

# Так же, как в задаче про гребцов,
# продемонстрируем два варианта решения:
# - при помощи базового `R` без всяких изысков
# - средствами пакета `dplyr`

# Данные: \href{https://chuansun76.com/2016/09/23/how-to-tell-the-greatness-of-a-movie-before-it-is-released-in-cinema/}{Chuan Sun}


# Переменная `imdb_score` кодирует рейтинг.
# Она числовая и в ней нет пропущенных значений.
class(mov$imdb_score)
sum(is.na(mov$imdb_score))

# Переменная `color` кодирует цвет фильма
# Она текстовая, и при открытии из исходного файла
# `.csv` превратилась в фактор.
# В ней есть пропущенные значения (`NA`).
class(mov$color)
sum(is.na(mov$color))

# Черно-белые фильмы закодированы с пробелом в
# начале (" Black and White").
# Это пригодится нам для фильтрации данных.
unique(mov$color) # уникальные значения
levels(mov$color) # уровни фактора


# Доверительный интервал для рейтинга черно-белых фильмов

# отфильтровываем среди фильмов с известным цветом только черно-белые
f_bw <- ! is.na(mov$color) & mov$color == ' Black and White'
imdb_score_bw <- mov$imdb_score[f_bw]         # рейтинг черно-белых фильмов

.mean <- mean(imdb_score_bw)                  # выборочное среднее
.n <- length(imdb_score_bw)                   # объем выборки
SE <- sd(imdb_score_bw)/ sqrt(.n)             # стандартная ошибка
t_crit <- qt(p = 0.975, df = .n - 1)          # критич. зн. t для данного n и p = 0.95
err <- t_crit * SE                            # предел погрешности
.mean - err # нижняя граница доверительного интервала
.mean + err # верхняя граница доверительного интервала

# Доверительные интервалы средствами пакета `dplyr`
mov %>% group_by(color) %>%        # группируем фильмы по цвету
  summarize(
    .mean = mean(imdb_score),                 # выборочное среднее
    .n = n(),                                 # объем выборки
    SE = sd(imdb_score),                      # стандартная ошибка
    t_crit = qt(p = 0.975, df = .n - 1),      # критич. зн. t для данного n и p = 0.95
    err = t_crit * SE,                        # предел погрешности
    lower = .mean - err,  #  нижняя граница доверительного интервала
    upper = .mean + err   # верхняя граница доверительного интервала
  )


# Строим доверительные интервалы в ggplot
ggplot(data = mov, aes(x = color, y = imdb_score)) +
  stat_summary(geom = 'pointrange', fun.data = mean_cl_normal)

# Улучшаем график
ggplot(data = mov, aes(x = color, y = imdb_score)) +
  stat_summary(geom = 'pointrange', fun.data = mean_cl_normal, shape = 3) +
  scale_x_discrete(na.translate = FALSE)

# Последний штрих и график готов
ggplot(data = mov, aes(x = color, y = imdb_score)) +
  stat_summary(geom = 'pointrange', fun.data = mean_cl_normal, shape = 3) +
  scale_x_discrete('Фильмы', labels = c('Черно-белые', 'Цветные'), na.translate = FALSE) +
  labs(y = 'Рейтинг на IMDB.com')


