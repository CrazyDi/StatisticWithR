# Работа с данными -------------------------------
# М.А. Варфоломеева, PhD
# В.М. Хайтов, к.б.н.
# Биологический факультет, СПбГУ


# Обзор типов данных --------------------------

# Мерные (интервальные) данные: непрерывные

# Пример --- температура чая в чашке.
temperature <- c(53, 79.5, 61, 70)
temperature

# Мерные (интервальные) данные: счетные

# Пример --- число кусков сахара в чашке.
sugar <- c(0, 2, 0, 3)
sugar

# Категориальные данные с двумя категориями

# Пример --- черный ли в чашке чай?   Черный --- 1
# или TRUE, зеленый --- 0 или FALSE

black_numeric <- c(0, 1, 1, 1)
black_numeric

black_txt <- c('зеленый', 'черный', 'черный', 'черный')
black_txt

black_logical <- c(FALSE, TRUE, TRUE, TRUE)
black_logical


# Категориальные данные со множеством категорий

# Пример --- тип напитка в чашке.

drink <- c('чай', 'вода', 'кофе', 'чай')
drink


# Категориальные данные с любым числом категорий
# часто представляют в виде факторов

drink
drink_fact <- factor(drink) # преобразуем в фактор

drink_fact # нам показывают уровни

as.numeric(drink_fact) # "внутри" фактора записаны числа


# Ранговые данные

# Пример --- субъективная оценка степени заварки чая:
# I = так себе, II = средний, III = крепкий

strength <- c('так себе', 'средний', 'крепкий', 'средний')
strength

# создадим упорядоченный фактор
strength_ord <- factor(strength,
                       levels = c('так себе', 'средний', 'крепкий'),
                       ordered = TRUE)
strength_ord             # нам показывают уровни и их порядок
as.numeric(strength_ord) # "внутри" фактора записаны числа


# Нужно уметь различать нулевые и отсутствующие значения

# Ноль означает, что что-то было измерено и
# значение измерения равно нулю.
sugar

# Отсутствующее значение или пропуск означает, что
# объект был, но измерение не было сделано.
sugar_1 <- c(0, NA, 0, 3)
sugar_1


# Логические данные  ------------------

# Обозначение логических данных в `R`
c(TRUE, FALSE)
c(T, F)


# Для проверки условий используются операторы сравнения
?Comparison # справка об операторах сравнения
?match      # о сопоставлении

# Проверяем выполнение условий для числовых векторов

sugar # этот вектор мы создали раньше

# В каких чашках ровно два куска сахара?
sugar == 2

# В каких чашках больше двух кусков сахара?
sweet <- sugar > 2
sweet

# В каких чашках 0 либо 3 куска сахара?
sugar %in% c(0, 3)

# Проверяем выполнение условий для текстовых векторов

strength # этот вектор мы создали раньше

# В каких чашках крепкий чай?
strength == 'крепкий'

# В каких чашках некрепкий чай?
mild <- strength != 'крепкий'
mild

# В каких чашках средний или крепкий чай?
strength %in% c('крепкий', 'средний')


# Логические операторы используются для
# объединения результатов нескольких проверок

?Logic # Справка о логических операторах

# Можно проверить несколько условий сразу

# В каких чашках некрепкий чай __И__ больше двух
# кусков сахара?

# Можно решить в два действия...
mild <- strength != 'крепкий'
mild
sweet <- sugar > 2
sweet
mild_and_sweet <- mild & sweet
mild_and_sweet

# или в одно действие.
mild_and_sweet <- strength != 'крепкий' & sugar > 2
mild_and_sweet


# Логические векторы умеют превращаться в числовые
# из 0 и 1

mild <- strength != 'крепкий'
mild
as.numeric(mild)


# Количество значений `TRUE` --- это сумма
# элементов логического вектора.
sum(mild)

# Доля значений `TRUE` среди всех значений ---
# это среднее значение логического вектора.
mean(mild)


# Поиск элементов вектора по номеру  ------------------

# Оператор `[ ]` извлекает из вектора элементы

# Потренируемся извлекать кусочки из вектора
# аббревиатур названий месяцев.
month.abb

month.abb[1] # элемент с номером 1

# Пробуем извлечь несколько элементов из вектора
# Самый очевидный код --- простое перечисление
# элементов --- вызовет ошибку.
month.abb[12, 1, 2] # этот код вызовет ошибку


# Для извлечения нескольких элементов используем
# вектор из их номеров

# Попробуем извлечь только зимние месяцы в
# правильном порядке.

id_winter <- c(12, 1, 2) # Индексы созданы заранее
month.abb[id_winter]

month.abb[c(12, 1, 2)] # Индексы используются сразу

month.abb[1:3] # Несколько элементов подряд


# К чему приведет обращение к несуществующему элементу?

month.abb[13] # в этом векторе нет 13-го элемента

# Исключение элементов

# Год без января.
month.abb[-1] # удаление элемента

# Год без зимних месяцев.
month.abb[-c(1, 11, 12)]  # удаление нескольких элементов

# Поиск элементов вектора по условию  ------------------

# Месяцы и времена года

# Вектор названий месяцев `month.abb` у нас уже есть.
month.abb

# Создадим для экспериментов вектор с названиями времен года.
season <- c('Winter', 'Winter',
            rep(c('Spring', 'Summer', 'Autumn'), each = 3),
            'Winter' )
season

# Сопряженные векторы можно использовать для
# перекрестного поиска значений.
cbind(season, month.abb)

# Ищем элементы вектора по условию

# Чтобы найти весенние месяцы, нужно определить,
# какие элементы в векторе `season` будут равны
# `'Spring'`.
season == 'Spring'

# Этот логический вектор можно использовать для
# отбора значений.
month.abb[season == 'Spring']

# Сложные варианты индексации

month.abb [season != 'Spring']

month.abb [season %in% c('Spring', 'Winter')]

# Выбираем четные и нечетные элементы вектора

# Вектор, в котором 1 - нечетное число, 0 - нечетное
1:length(month.abb) %% 2

# Логический вектор где TRUE для нечетных элементов
is_odd <- as.logical(1:length(month.abb) %% 2)
is_odd

month.abb[is_odd] # Нечетные элементы

month.abb[! is_odd] # Четные элементы


# Датафреймы и операции с ними  ------------------


# Данные о персонажах "Звездных войн"

# Работу с датафреймами мы разберем на примере
# фрагмента данных о персонажах "Звездных войн" из
# базы \href{https://swapi.co/}{SWAPI
# (https://swapi.co/)}.

# Скачайте файл `tiny_starwars.RData` и положите
# его в папку `data` внутри вашей рабочей папки с
# материалами курса (см. видео "Организация
# рабочего пространства").

# Откроем данные из файла `tiny_starwars.RData`
load(file = 'data/tiny_starwars.RData')
# Если все правильно, то в вашем рабочем
# пространстве появится переменная `SW`.

SW # вывод всего датафрейма в консоль

# Как посмотреть, что находится в датафрейме?

# Для больших датафреймов удобнее отображать лишь часть строк.
head(SW)      # первые несколько строк
tail(SW, n = 2) # последние несколько строк

# Сколько строк и столбцов, как называются переменные?
nrow(SW)  # Количество строк
ncol(SW)  # Количество столбцов
colnames(SW) # Имена переменных в датафрейме

# Подробная информация о структуре датафрейма
str(SW)

# Есть ли пропущенные значения и сколько их?
is.na(SW) # матрица, где TRUE соответствует NA в исходных данных
colSums(is.na(SW)) # суммируем число NA по столбцам


# Работа с переменными датафрейма при помощи `$` ------------------

# Мы продолжим разбирать работу с датафреймами на
# примере фрагмента данных о персонажах "Звездных
# войн" из базы \href{https://swapi.co/}{SWAPI
# (https://swapi.co/)}.
# Данные содержатся в файле `tiny_starwars.RData`.

# Обращение к переменным датафрейма при помощи `$`
SW$name
SW$species
SW$mass

# С переменными можно работать как с векторами

# Можно извлекать из переменных отдельные значения по их номерам.
SW$name[c(1, 6)] # Как зовут существ из строк 1 и 6 в датафрейме?

# Можно использовать переменные в вычислениях.
table(SW$species) # Сколько существ разных видов в датафрейме?

# Можно извлекать из переменных значения по
# условию и использовать их в вычислениях

sum(SW$species == 'Human') # Сколько всего людей?

SW$name[SW$species == 'Human'] # Как зовут людей?

mean(SW$mass[SW$species == 'Human'], na.rm = TRUE) # Какова средняя масса людей?

# При помощи знака `$` можно добавлять переменные в датафрейм

SW$height_m <- SW$height / 100  # Переводим рост из сантиметров в метры
SW$height_m

# Созданные переменные будут добавлены в конец датафрейма.
head(SW, 2)

# Работа с фрагментами датафрейма при помощи `[ , ]` ------------------

# Мы продолжим разбирать работу с датафреймами на
# примере фрагмента данных о персонажах "Звездных
# войн" из базы \href{https://swapi.co/}{SWAPI
# (https://swapi.co/)}.
# Данные содержатся в файле `tiny_starwars.RData`.

# Любой элемент датафрейма можно извлечь при помощи `[ , ]`

head(SW)

# Какой рост у Дарта Вейдера?
SW[4, 2] # Вызываем элемент из 4-й строки, 2-го столбца (рост Дарта Вейдера)


# Любую переменную тоже можно извлечь при помощи `[ , ]`

# Существа каких видов есть в нашем датасете?
# Эти варианты кода дадут одинаковый результат:
SW$species       # при помощи знака `$`
SW[ , 6]         # переменная номер 6
SW[ , 'species'] # переменная вид

unique(SW[ , 'species'])


# Можно извлечь сразу несколько переменных

# В скольких фильмах участвовали персонажи из нашего датасета?
# Эти варианты кода дадут одинаковый результат:
SW[ , c(1, 7)]              # Столбцы 1 и 7
SW[ , c("name", "n_films")] # Имена и число фильмов


# Нужные строки можно извлечь по номерам или по условию

# Можно использовать номера строк, если они известны заранее.
SW[c(8, 1), ] # Строки 8 и 1 - это мастер Йода и Люк Скайуокер

# Можно использовать поиск по условию, если номера
# строк точно не известны.
SW[SW$species == 'Droid', ] # Строки с данными про дроидов

# Мы можем выбрать только нужные данные, используя
# комбинацию фильтров

# Допустим, мы хотим исключить из анализа дроидов
# (строки 2 и 3) и оставить только переменные,
# кодирующие имя рост и вес.

# Эти варианты кода дадут одинаковый результат:
SW[-c(2,3), -c(4:6, 8)]     # удаляем строки и столбцы по номерам
SW[SW$species != 'Droid', c('name', 'height', 'mass')] # выбираем по условию и именам

# Создание датафреймов с нуля -------------------


# Датафрейм можно создать из векторов одинаковой длины
p_name <- c('Luke Skywalker', 'Darth Vader', 'Obi-Wan Kenobi', 'Yoda')
planet <- c('Tatooine', 'Tatooine', 'Stewjon', NA)
starships <- c(2, 1, 5, 0)

jedi <- data.frame(name = p_name,
                   homeworld = planet,
                   n_starships = starships)
jedi

# По-умолчанию функция data.frame() превратит
# текстовые векторы в факторы
str(jedi)

# Можно избежать превращения текста в факторы
jedi <- data.frame(name = p_name,
                   homeworld = planet,
                   n_starships = starships,
                   stringsAsFactors = FALSE)
str(jedi)

# И вручную преобразовать то, что нужно
jedi$homeworld <- factor(jedi$homeworld)
str(jedi)


# Загрузка внешних данных в `R`  ------------------

# Роковой рейс "Титаника"

# Скачайте с сайта файлы  `Titanic_xls_book.xls` и
# `Titanic.csv` и положите их в папку `data`
# внутри рабочей директории.
# Данные: Dawson, 1995   Источник: пакет `datasets`

# Чтение .xls / .xlsx файлов в `R`

library(readxl) # Пакет для чтения файлов Excel

titanic <- read_xls("data/Titanic_xls_book.xls", sheet = "Лист1")
head(titanic)

# Результат чтения --- объект класса `tibble`,
# большая часть его свойств такая же, как у
# `data.frame`.
?tibble # Справка о tibble

# Чтение .csv файла в `R`
read.table('data/Titanic.csv')

# С дефолтными настройками получается плохо, так
# как не указаны важные параметры функции
# `read.table()`.

read.table('data/Titanic.csv',
           sep = ';',
           header = TRUE)


# Остается только положить загруженные данные в
# некоторую переменную.
titanic <- read.table('data/Titanic.csv',
                      sep = ';',
                      header = TRUE)

# Внешние данные из Сети

# Можно вместо пути к локальному файлу указать
# путь к сетевому ресурсу.
read.table(
  "http://www.foo.foo.edu/foo/foo/data/titanic.csv",
  sep = ";",
  header = TRUE)


# Опрятные данные (Tidy data)  ------------------

# Исходные данные часто приходится приводить в порядок

# В среде `R` создано несколько удобных пакетов
# для преобразования данных:
# - `reshape2`
# - `dplyr`
# - `tidyr`

# Широкий и длинный формат данных

# С представлением данных в широком и длинном
# формате мы познакомимся на примере "Титаника"
# (`Titanic.csv`)
# Данные: Dawson, 1995  Источник: пакет `datasets`

# Широкий формат данных
titanic <- read.table('data/Titanic.csv',
                      sep = ';',
                      header = TRUE)
head(titanic, 8)

# Длинный формат данных
library(tidyr)
long_titanic <- uncount(titanic,
                        weights = Freq)
head(long_titanic, 10)

# Подходящую функцию для преобразования в длинный
# формат можно найти в пакете `tidyr`.
