# Краткое введение в мир линейной алгебры
# В.М. Хайтов, к.б.н.
# Биологический факультет, СПбГУ

# чтобы избежать "scientific notation"
options(scipen = 6, digits = 3)


## Линейная алгебра для линейных моделей  ----------------------


## Матрицы  ----------------------

## Разновидности матриц  ----------------------


## Основные действия с матрицами  ----------------------


## Создание матриц в R

matrix(data = 1:12, ncol = 3)

matrix(data = 1:12, ncol = 3, byrow = TRUE)

matrix(data = c(1, 2, 3, 6, 5, 4, 7, 8, 9, 12, 11, 10), nrow = 4, byrow = TRUE)


## Транспонирование матриц

# Исходная матрица $\mathbf{A}$
A <- matrix(1:12, ncol = 3)
A

# Транспонированная матрица $\mathbf{B} = \mathbf{A}'$
B <- t(A)
B


# Ко всем элементам матрицы можно прибавить (вычесть) одно и то же число
A
A + 4

# Все элементы матрицы можно умножить (разделить) на одно и то же число
B
B * 100

# Можно сложить две матрицы одинакового размера
A
A + A

# Но! Нельзя складывать матрицы разных размеров
B
A + B

## Простое умножение матрицы на вектор
A # некоторая матрица 4х3
A * c(10, 11, 12, 13)

## Матричное умножение

## Для чего это нужно
# В доме есть следующие электроприборы.
# Какова будет суммарная мощность всех электроприборов, если их включить одновременно?
# Электроприбор & Количество & Мощность (Вт) \\
# Чайник & 2 шт & 1200 \\
# Обогреватели & 3 шт. & 1300 \\
# Осушитель & 1 шт. & 1100 \\
# Стиральная машина & 1 шт.& 1500 \\
# Фен & 2 шт. & 800 \\
#
## Решение
a <- c(2, 3, 1, 1, 2)
b <- c(1200, 1300, 1100, 1500, 800)
a %*% b

## Матричное умножение матрицы на вектор
A %*% c(10, 10, 10)
# Но! если поменять местами множители, то будет ошибка
c(10, 10, 10) %*% A


## Матричное умножение вектора на матрицу
c(10, 10, 10, 10) %*% A
# Но! если поменять местами множители, то будет ошибка
A %*% c(10, 10, 10, 10)

## Зачем это нужно
# Представим себе, что вы решили купить четыре товара, по следующим ценам
# Товар & Цена \\
# Товар 1 & 10 \\
# Товар 2 & 20 \\
# Товар 3 & 30 \\
# Товар 4 & 40 \\
#
# Прямых выходов на продавца у вас нет, но есть три посредника, которые выставляют следующие "накрутки" цен.
# Какой из посредников выгоднее?
#
#  & Товар 1 & Товар 2 & Товар 3 & Товар 4 \\
# Посредник 1 & 0.1& 0.15& 0.05& 0.05 \\
# Посредник 2 & 0.15& 0.15& 0.09& 0.01 \\
# Посредник 3 & 0.2& 0.05& 0.1& 0.1  \\
#
# Решение
cost <- c(10, 20, 30, 40)
retailer <- matrix(c(0.1, 0.15, 0.05, 0.05,
                     0.15, 0.15, 0.09, 0.01,
                     0.2, 0.05, 0.1, 0.1 ), byrow = TRUE, ncol = 4)
retailer %*% cost



## Матричное умножение
A %*% B
B %*% A

# Такое произведение матриц возможно
A %*% t(A)
# Но! Нельзя произвести такое умножение
A %*% A


## Зачем это нужно
# Как вычисляется корреляция?
# Используем известные нам данные по размеру головного мозга (Willerman et al., 1991)
# Специализированная функция R для вычисления матрицы корреляций
brain <- read.csv("data/IQ_brain.csv", header = TRUE)
br <- brain[ , c("PIQ", "MRINACount")]
cor(br)

## Вычисление коэффициента корреляции через произведение матриц
br <- as.matrix(br) # превращаем датафрейм в матрицу
br_scaled <- scale(br) # стандартизуем исходные значения
cor_matrix <- t(br_scaled) %*% br_scaled / (nrow(br_scaled) - 1)
cor_matrix

## Решение систем уравнений при помощи матриц  ----------------------

## Определитель матрицы
# Определитель бывает *только у квадратных матриц*.
C <- matrix(round(rnorm(12, 10, 3)), ncol = 3)
C
det(C)

# Для получения квадратной матрицы воспользуемся важным свойством матриц:
CC <-  t(C) %*% C
CC

det(CC)


## Обращение (инверсия) матриц

# Создадим квадратную матрицу
X <- matrix(c(seq(1, 8),10), nrow = 3, byrow = TRUE)
X

# Ее определитель не равен нулю, стало быть возможно обращение этой матрицы.
det(X)

# Обратная матрица
solve(X)

round(solve(X) %*% X )


## Решим задачу из школьного учебника
# 3x - 1y + 1z = 4\\
# 2x - 5y - 3z = -17 \\
# 1x + 1y - 1z = 0
#
# Создадим матрицу, включающую коэффициенты уравнений
Coef <- matrix(c(3, -1, 1,
                 2, -5, -3,
                 1, 1, -1), byrow = TRUE, ncol = 3)
# Посмотрим на определитель этой матрицы
det(Coef)
# Решение существует!
Val <- c(4,-17, 0) # вектор результатов
solve(Coef) %*% Val # решение

# Проверим
(3 * 1) - (1 * 2) + (1 * 3)
(2 * 1) - (5 * 2) - (3 * 3)
(1 * 1) + (1 * 2) - (1 * 3)


## Уравнение регрессии в матричном виде  ----------------------

## Коэффициенты, подобранные с помощью функции `lm()`
M_brain <- lm(PIQ ~ MRINACount, data = brain)
coef(M_brain)

## Вычисление коэффициентов линейной регрессии вручную

# Создадим модельную матрицу.
X <- model.matrix(~MRINACount, data = brain)
head(X)

# вектор значений зависимой переменной
Y <- brain$PIQ

b <- solve(t(X) %*% X) %*% (t(X) %*% Y)

b


## Остатки в матричном виде
H <- X %*% solve(t(X) %*% X) %*% t(X) # hat-matrix

I <- diag(rep(1, nrow(brain))) # единичная матрица

e <- (I - H) %*% Y # вектор-столбец остатков



## Строим график модели вручную

# Шаг 1. Формируем искусственный датасет со всеми возможными значениями предиктора.
new_data <- data.frame(MRINACount = seq(min(brain$MRINACount), max(brain$MRINACount), 100))
head(new_data)

# Шаг 2. Формируем модельную матрицу для искусственно созданных данных.
X2 <- model.matrix( ~ MRINACount, data = new_data)
head(X2)

# Шаг 3. Вычисляем предсказанные значения для искусственно созданных данных.
new_data$predicted <- as.numeric(X2 %*% b)

library (ggplot2)
Pl_manual <- ggplot(new_data, aes(x = MRINACount, y = predicted)) +
  geom_line() +
  geom_point(data = brain, aes(x = MRINACount, y = PIQ)) +
  theme_bw()
Pl_manual


## Доверительная зона регрессии в матричном виде  ----------------------

## Вариационно-ковариационная матрица
M_brain <- lm(PIQ ~ MRINACount, data = brain)
vcov(M_brain)


# Чтобы вычислить вариационно-ковариационную матрицу, нам понадобится $MS_e$
y_hat <- X %*% b # предсказанные значения
e <- brain$PIQ - y_hat # остатки
MSe <- sum(e^2)/(length(e) - length(b))
MSe

# В summary() это квадрат `Residual standard error: 21 on 38 degrees of freedom`
summary(M_brain)

## Вычисление вариационо-ковариационной матрицы вручную
Vb <- MSe * solve(t(X) %*% X)
Vb



## Продолжаем строить график

# Шаг 5. Вычисляем границы доверительных интервалов

# вычисляем стандартные ошибки путем перемножения матриц
new_data$se <- sqrt(diag(X2 %*% Vb %*% t(X2)))

t_crit <- qt(p = 0.975, df = nrow(brain) - length(coef(M_brain))) # критическое значение t

# вычисляем доверительные интервалы:
# верхняя граница доверительной области
new_data$upper  <- new_data$predicted + t_crit * new_data$se
# нижняя граница доверительной области
new_data$lower  <- new_data$predicted - t_crit * new_data$se


# {Шаг 6. Строим график}
Pl_manual_se <- Pl_manual +
  geom_line(data = new_data, aes(x = MRINACount, y = upper),
            linetype = 2, size = 1) +
  geom_line(data = new_data, aes(x = MRINACount, y = lower),
            linetype = 2, size = 1) +
  ggtitle("Построено вручную")

